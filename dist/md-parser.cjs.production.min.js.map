{"version":3,"file":"md-parser.cjs.production.min.js","sources":["../src/Token.ts","../src/markup/Image.ts","../src/TokenReader.ts","../src/BaseParser.ts","../src/markup/Paragraph.ts","../src/markup/Header.ts","../src/markup/Text.ts","../src/markup/BlockMarkableItem.ts","../src/markup/Strikeout.ts","../src/markup/Strong.ts","../src/markup/Emphasis.ts","../src/markup/Code.ts","../src/MdParser.ts"],"sourcesContent":["export enum Token {\n  END,\n  EMPHASIS,\n  STRONG,\n  STRIKEOUT,\n  CODE,\n  TEXT,\n  _EMPHASIS,\n  __STRONG,\n  IMG\n}\n","import {BlockItem} from './BlockItem';\n\nexport class Image implements BlockItem {\n  private readonly name: string;\n  private readonly src: string;\n\n  constructor(name: string, src: string) {\n    this.name = name;\n    this.src = src;\n  }\n\n  toHtml(st: Array<string>): void {\n    st.push('<img alt=\\'');\n    st.push(this.name);\n    st.push('\\' src=\\'');\n    st.push(this.src);\n    st.push('\\'>');\n  }\n\n  toMarkdown(st: Array<string>): void {\n    throw st;\n  }\n\n\n}\n","import { Token } from './Token';\nimport { Image } from './markup/Image';\n\nexport class TokenReader {\n  private readonly source: string = '';\n\n  private pos: number = 0;\n\n  private curToken: Token = Token.CODE;\n\n  private curStringToken: string = '';\n\n  private tags: string[] = ['**', '__', '--', '*', '_', '`', '!['];\n\n  private imgName: string = '';\n\n  private imgSrc: string = '';\n\n  private strToToken = new Map([\n    ['**', Token.STRONG],\n    ['*', Token.EMPHASIS],\n    ['--', Token.STRIKEOUT],\n    ['`', Token.CODE],\n    ['_', Token._EMPHASIS],\n    ['__', Token.__STRONG],\n    ['![', Token.IMG],\n  ]);\n\n  private curTag: string = '';\n\n  constructor(source: string) {\n    this.source = source;\n    this.pos = 0;\n  }\n\n  private checkTag(): boolean {\n    for (const tag of this.tags) {\n      if (this.source.startsWith(tag, this.pos)) {\n        this.curTag = tag;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private test(ch: string): boolean {\n    return this.pos < this.source.length && ch === this.source[this.pos];\n  }\n\n  private parseImg(): void {\n    const start: number = this.pos;\n    let mid: number;\n    let end: number;\n    while (this.pos < this.source.length &&\n          !this.source.startsWith('](', this.pos)) {\n      this.pos++;\n    }\n    if (this.pos < this.source.length && this.source.startsWith('](', this.pos)) {\n      mid = this.pos;\n      while (this.pos < this.source.length && !this.source.startsWith(')', this.pos)) {\n        this.pos++;\n      }\n      if (this.pos < this.source.length && this.source.startsWith(')', this.pos)) {\n        end = this.pos;\n        this.imgName = this.source.substring(start, mid);\n        this.imgSrc = this.source.substring(mid + 2, end);\n        this.pos++;\n        return;\n      }\n    }\n    throw 'atata';\n  }\n\n  public getImg(): Image {\n    return new Image(this.imgName, this.imgSrc);\n  }\n\n  public nextToken(): Token {\n    if (this.pos >= this.source.length) {\n      return Token.END;\n    }\n\n    if (this.checkTag()) {\n      this.curStringToken = this.curTag;\n      const temp = this.strToToken.get(this.curTag);\n      this.curToken = temp === undefined ? Token.CODE : temp;\n      this.pos += this.curTag.length;\n      if (this.curToken === Token.IMG) {\n        this.parseImg();\n      }\n      return this.curToken;\n    }\n\n    const sb: Array<string> = new Array<string>();\n\n    while (this.pos < this.source.length && !this.checkTag()) {\n      const ch: string = this.source.charAt(this.pos++);\n      if (ch === '<') {\n        sb.push('&lt;');\n      } else if (ch === '>') {\n        sb.push('&gt;');\n      } else if (ch === '&') {\n        sb.push('&amp;');\n      } else if (ch === '\\\\' && this.pos < this.source.length && (this.test('*') || this.test('_'))) {\n        sb.push(this.source.charAt(this.pos++));\n      } else {\n        sb.push(ch);\n      }\n    }\n\n    this.curToken = Token.TEXT;\n\n    this.curStringToken = sb.join('');\n\n    return this.curToken;\n  }\n\n\n  public getStringToken(): string {\n    return this.curStringToken;\n  }\n}\n","import { TokenReader } from './TokenReader';\nimport { Token } from './Token';\n\nexport abstract class BaseParser {\n  protected tr: TokenReader;\n  protected curToken: Token;\n  protected curStringToken: string;\n\n  protected nextToken(): void {\n    this.curToken = this.tr.nextToken();\n    this.curStringToken = this.tr.getStringToken();\n  }\n\n  protected constructor() {\n    this.tr = new TokenReader('');\n    this.curToken = Token.CODE;\n    this.curStringToken = '';\n  }\n}\n","import {Markable} from './Markable';\nimport {BlockItem} from './BlockItem';\n\nexport class Paragraph implements Markable {\n  private readonly elements: Array<BlockItem>;\n\n  constructor(elements: Array<BlockItem>) {\n    this.elements = new Array<BlockItem>(...elements);\n  }\n\n  toHtml(st: Array<string>): void {\n    st.push('<p>');\n    for (const elem of this.elements) {\n      elem.toHtml(st);\n    }\n    st.push('</p>');\n  }\n\n  toMarkdown(st: Array<string>): void {\n    for (const elem of this.elements) {\n      elem.toMarkdown(st);\n    }\n  }\n\n\n}\n","import {Markable} from './Markable';\nimport {BlockItem} from './BlockItem';\n\nexport class Header implements Markable {\n\n  private elements: Array<BlockItem>;\n  private hLevel: number;\n\n  constructor(elements: Array<BlockItem>, hLevel: number) {\n    this.hLevel = hLevel;\n    this.elements = new Array<BlockItem>(...elements);\n  }\n\n  toHtml(st: Array<string>): void {\n    st.push(`<h${this.hLevel}>`);\n    for (const elem of this.elements) {\n      elem.toHtml(st);\n    }\n    st.push(`</h${this.hLevel}>`);\n  }\n\n  toMarkdown(st: Array<string>): void {\n    throw st;\n  }\n\n}\n","import {BlockItem} from './BlockItem';\n\nexport class Text implements BlockItem {\n  private text: string;\n\n  constructor(text: string) {\n    this.text = text;\n  }\n\n  toHtml(st: Array<string>): void {\n    st.push(this.text);\n  }\n\n  toMarkdown(st: Array<string>): void {\n    st.push(this.text);\n  }\n\n\n}\n","import {BlockItem} from './BlockItem';\n\nexport abstract class BlockMarkableItem implements BlockItem {\n  private elements: Array<BlockItem>;\n\n  protected constructor(elements: Array<BlockItem>) {\n    this.elements = new Array<BlockItem>(...elements);\n  }\n\n  protected toMarkdownSuper(start: string, end: string, st: Array<string>): void {\n    st.push(start);\n    for (const elem of this.elements) {\n      elem.toMarkdown(st);\n    }\n    st.push(end);\n  }\n\n  protected toHtmlSuper(start: string, end: string, st: Array<string>): void {\n    st.push(start);\n    for (const elem of this.elements) {\n      elem.toMarkdown(st);\n    }\n    st.push(end);\n  }\n\n  abstract toMarkdown(st: Array<string>): void;\n\n  abstract toHtml(st: Array<string>): void;\n}\n","import {BlockMarkableItem} from './BlockMarkableItem';\nimport {BlockItem} from './BlockItem';\n\nexport class Strikeout extends BlockMarkableItem {\n  constructor(elements: Array<BlockItem>) {\n    super(elements);\n  }\n\n  toHtml(st: Array<string>): void {\n    super.toHtmlSuper('<s>', '</s>', st);\n  }\n\n  toMarkdown(st: Array<string>): void {\n    super.toMarkdownSuper('~', '~', st);\n  }\n}\n","import {BlockMarkableItem} from './BlockMarkableItem';\nimport {BlockItem} from './BlockItem';\n\nexport class Strong extends BlockMarkableItem {\n  constructor(elements: Array<BlockItem>) {\n    super(elements);\n  }\n\n  toHtml(st: Array<string>): void {\n    super.toHtmlSuper('<strong>', '</strong>', st);\n  }\n\n  toMarkdown(st: Array<string>): void {\n    super.toMarkdownSuper('__', '__', st);\n  }\n}\n","import {BlockItem} from './BlockItem';\nimport {BlockMarkableItem} from './BlockMarkableItem';\n\nexport class Emphasis extends BlockMarkableItem {\n\n  constructor(elements: Array<BlockItem>) {\n    super(elements);\n  }\n\n  toHtml(st: Array<string>): void {\n    super.toHtmlSuper('<em>', '</em>', st);\n  }\n\n  toMarkdown(st: Array<string>): void {\n    super.toMarkdownSuper('*', '*', st);\n  }\n}\n","import {BlockMarkableItem} from './BlockMarkableItem';\nimport {BlockItem} from './BlockItem';\n\nexport class Code extends BlockMarkableItem {\n\n  constructor(elements: Array<BlockItem>) {\n    super(elements);\n  }\n\n  toHtml(st: Array<string>): void {\n    super.toHtmlSuper('`', '`', st);\n  }\n\n  toMarkdown(st: Array<string>): void {\n    super.toMarkdownSuper('<code>', '</code>', st);\n  }\n}\n","import { BaseParser } from './BaseParser';\nimport { Markable } from './markup/Markable';\nimport { TokenReader } from './TokenReader';\nimport { Paragraph } from './markup/Paragraph';\nimport { Header } from './markup/Header';\nimport { Token } from './Token';\nimport { BlockItem } from './markup/BlockItem';\nimport { Text } from './markup/Text';\nimport { Strikeout } from './markup/Strikeout';\nimport { Strong } from './markup/Strong';\nimport { Emphasis } from './markup/Emphasis';\nimport { Code } from './markup/Code';\n\n\nexport class MdParser extends BaseParser {\n  private readonly source: Array<string>;\n  private curElem: string = '';\n  private curLine: string | null = '';\n  private headerStarts = ['###### ', '##### ', '#### ', '### ', '## ', '# '];\n\n  private hLevel: number = 0;\n\n  constructor(data: string) {\n    super();\n    this.source = data.split('\\n');\n  }\n\n\n  public parse(): Array<Markable> {\n    const ans = new Array<Markable>();\n    while (this.nextElement()) {\n      if (this.isParagraph()) {\n        this.tr = new TokenReader(this.curElem);\n        this.nextToken();\n        ans.push(new Paragraph(this.parseItems()));\n      } else {\n        this.tr = new TokenReader(this.curElem.substring(this.hLevel + 1));\n        this.nextToken();\n        ans.push(new Header(this.parseItems(), this.hLevel));\n      }\n    }\n    return ans;\n  }\n\n  private isText(token: Token) {\n    return token === Token.TEXT;\n  }\n\n  private parseItems(): Array<BlockItem> {\n    const ans = new Array<BlockItem>();\n    while (this.curToken !== Token.END) {\n      if (this.isText(this.curToken)) {\n        ans.push(new Text(this.curStringToken));\n        this.nextToken();\n      } else if (this.curToken === Token.IMG) {\n        ans.push(this.tr.getImg());\n        this.nextToken();\n      } else {\n        const start: Token = this.curToken;\n        this.nextToken();\n        ans.push(...this.parseItem(start));\n      }\n    }\n    return ans;\n  }\n\n  private parseItem(start: Token): Array<BlockItem> {\n    const ans = new Array<BlockItem>();\n    while (this.curToken !== Token.END && this.curToken !== start) {\n      if (this.isText(this.curToken)) {\n        ans.push(new Text(this.curStringToken));\n        this.nextToken();\n      } else if (this.curToken === Token.IMG) {\n        ans.push(this.tr.getImg());\n        this.nextToken();\n      } else {\n        const st: Token = this.curToken;\n        this.nextToken();\n        ans.push(...this.parseItem(st));\n      }\n    }\n    if (this.curToken === start) {\n      this.nextToken();\n      return this.create(ans, start);\n    } else if (start === Token.EMPHASIS || start === Token._EMPHASIS) {\n      const temp = new Array<BlockItem>();\n      temp.push(new Text(this.tokenToString(start)));\n      temp.push(...ans);\n      this.nextToken();\n      return temp;\n    } else {\n      throw 'Unclosed tag! expected ' + start + 'found ' + this.curToken;\n    }\n  }\n\n  private tokenToString(token: Token): string {\n    switch (token) {\n      case Token.STRIKEOUT: {\n        return '--';\n      }\n      case Token.STRONG: {\n        return '**';\n      }\n      case Token.__STRONG: {\n        return '__';\n      }\n      case Token.EMPHASIS: {\n        return '*';\n      }\n      case Token._EMPHASIS: {\n        return '_';\n      }\n      case Token.CODE: {\n        return '`';\n      }\n      default: {\n        throw 'atata';\n      }\n    }\n  }\n\n  private create(ans: Array<BlockItem>, token: Token): Array<BlockItem> {\n    switch (token) {\n      case Token.STRIKEOUT: {\n        return [new Strikeout(ans)];\n      }\n      case Token.STRONG: {\n        return [new Strong(ans)];\n      }\n      case Token.__STRONG: {\n        return [new Strong(ans)];\n      }\n      case Token.EMPHASIS: {\n        return [new Emphasis(ans)];\n      }\n      case Token._EMPHASIS: {\n        return [new Emphasis(ans)];\n      }\n      case Token.CODE: {\n        return [new Code(ans)];\n      }\n      default: {\n        throw 'atata';\n      }\n    }\n  }\n\n  private skipEmpties(): void {\n    this.curLine = this.next();\n    while (this.curLine !== null && this.curLine === '') {\n      this.curLine = this.next();\n    }\n  }\n\n  private nextElement(): boolean {\n    this.skipEmpties();\n    if (this.curLine === null) {\n      return false;\n    }\n    const elem = new Array<string>();\n    elem.push(this.curLine);\n    this.curLine = this.next();\n    while (this.curLine !== null && this.curLine !== '') {\n      elem.push('\\n');\n      elem.push(this.curLine);\n      this.curLine = this.next();\n    }\n    this.curElem = elem.join('');\n    return true;\n  }\n\n  next(): string | null {\n    const exp = this.source.length === 0 ? null : this.source.shift();\n    if (exp !== undefined) {\n      return exp;\n    }\n    return null;\n  }\n\n  private isParagraph(): boolean {\n    for (const headerStart of this.headerStarts) {\n      if (this.curElem.startsWith(headerStart)) {\n        this.hLevel = headerStart.length - 1;\n        return false;\n      }\n    }\n    return true;\n  }\n\n}\n"],"names":["Token","Image","name","src","toHtml","st","push","this","toMarkdown","TokenReader","source","CODE","Map","STRONG","EMPHASIS","STRIKEOUT","_EMPHASIS","__STRONG","IMG","pos","checkTag","tags","tag","startsWith","curTag","test","ch","length","parseImg","mid","end","start","imgName","substring","imgSrc","getImg","nextToken","END","curStringToken","temp","strToToken","get","curToken","undefined","sb","Array","charAt","TEXT","join","getStringToken","BaseParser","tr","Paragraph","elements","Header","hLevel","Text","text","BlockMarkableItem","toMarkdownSuper","toHtmlSuper","Strikeout","_BlockMarkableItem","Strong","Emphasis","Code","MdParser","data","split","parse","ans","nextElement","isParagraph","curElem","parseItems","isText","token","parseItem","create","tokenToString","skipEmpties","curLine","next","elem","exp","shift","headerStarts","headerStart"],"mappings":"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"}