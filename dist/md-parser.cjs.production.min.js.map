{"version":3,"file":"md-parser.cjs.production.min.js","sources":["../src/Token.ts","../src/markup/Image.ts","../src/TokenReader.ts","../src/BaseParser.ts","../src/markup/Paragraph.ts","../src/markup/Header.ts","../src/markup/Text.ts","../src/markup/BlockMarkableItem.ts","../src/markup/Strikeout.ts","../src/markup/Strong.ts","../src/markup/Emphasis.ts","../src/markup/Code.ts","../src/MdParser.ts"],"sourcesContent":["export enum Token {\n    END, EMPHASIS, STRONG, STRIKEOUT, CODE, TEXT, _EMPHASIS, __STRONG, IMG\n}\n","import {BlockItem} from './BlockItem';\n\nexport class Image implements BlockItem {\n    private readonly name: string;\n    private readonly src: string;\n\n    constructor(name: string, src: string) {\n        this.name = name;\n        this.src = src;\n    }\n\n    toHtml(st: Array<string>): void {\n        st.push('<img alt=\\'');\n        st.push(this.name);\n        st.push('\\' src=\\'');\n        st.push(this.src);\n        st.push('\\'>');\n    }\n\n    toMarkdown(st: Array<string>): void {\n        throw st;\n    }\n\n\n}\n","import {Token} from './Token';\nimport {Image} from './markup/Image';\n\nexport class TokenReader {\n    private readonly source: string = '';\n\n    private pos: number = 0;\n\n    private curToken: Token = Token.CODE;\n\n    private curStringToken: string = '';\n\n    private tags: string[] = ['**', '__', '--', '*', '_', '`', '!['];\n\n    private imgName: string = '';\n\n    private imgSrc: string = '';\n\n    private strToToken = new Map([\n        ['**', Token.STRONG],\n        ['*', Token.EMPHASIS],\n        ['--', Token.STRIKEOUT],\n        ['`', Token.CODE],\n        ['_', Token._EMPHASIS],\n        ['__', Token.__STRONG],\n        ['![', Token.IMG]\n    ]);\n\n    private curTag: string = '';\n\n    constructor(source: string) {\n        this.source = source;\n        this.pos = 0;\n    }\n\n    private checkTag(): boolean {\n        for (const tag of this.tags) {\n            if (this.source.startsWith(tag, this.pos)) {\n                this.curTag = tag;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private test(ch: string): boolean {\n        return this.pos < this.source.length && ch === this.source[this.pos];\n    }\n\n    private parseImg(): void {\n        const start: number = this.pos;\n        let mid: number;\n        let end: number;\n        while (this.pos < this.source.length && !this.source.startsWith('](', this.pos)) {\n            this.pos++;\n        }\n        if (this.pos < this.source.length && this.source.startsWith('](', this.pos)) {\n            mid = this.pos;\n            while (this.pos < this.source.length && !this.source.startsWith(')', this.pos)) {\n                this.pos++;\n            }\n            if (this.pos < this.source.length && this.source.startsWith(')', this.pos)) {\n                end = this.pos;\n                this.imgName = this.source.substring(start, mid);\n                this.imgSrc = this.source.substring(mid + 2, end);\n                this.pos++;\n                return;\n            }\n        }\n        throw 'atata';\n    }\n\n    public getImg(): Image {\n        return new Image(this.imgName, this.imgSrc);\n    }\n\n    public nextToken(): Token {\n        if (this.pos >= this.source.length) {\n            return Token.END;\n        }\n\n        if (this.checkTag()) {\n            this.curStringToken = this.curTag;\n            const temp = this.strToToken.get(this.curTag);\n            this.curToken = temp === undefined ? Token.CODE : temp;\n            this.pos += this.curTag.length;\n            if (this.curToken === Token.IMG) {\n                this.parseImg();\n            }\n            return this.curToken;\n        }\n\n        const sb: Array<string> = new Array<string>();\n\n        while (this.pos < this.source.length && !this.checkTag()) {\n            const ch: string = this.source.charAt(this.pos++);\n            if (ch === '<') {\n                sb.push('&lt;');\n            } else if (ch === '>') {\n                sb.push('&gt;');\n            } else if (ch === '&') {\n                sb.push('&amp;');\n            } else if (ch === '\\\\' && this.pos < this.source.length && (this.test('*') || this.test('_'))) {\n                sb.push(this.source.charAt(this.pos++));\n            } else {\n                sb.push(ch);\n            }\n        }\n\n        this.curToken = Token.TEXT;\n\n        this.curStringToken = sb.join('');\n\n        return this.curToken;\n    }\n\n\n    public getStringToken(): string {\n        return this.curStringToken;\n    }\n}\n","import {TokenReader} from './TokenReader';\nimport {Token} from './Token';\n\nexport abstract class BaseParser {\n    protected tr: TokenReader;\n    protected curToken: Token;\n    protected curStringToken: string;\n\n    protected nextToken(): void {\n        this.curToken = this.tr.nextToken();\n        this.curStringToken = this.tr.getStringToken();\n    }\n\n    protected constructor() {\n        this.tr = new TokenReader('');\n        this.curToken = Token.CODE;\n        this.curStringToken = '';\n    }\n}\n","import {Markable} from './Markable';\nimport {BlockItem} from './BlockItem';\n\nexport class Paragraph implements Markable {\n    private readonly elements: Array<BlockItem>;\n\n    constructor(elements: Array<BlockItem>) {\n        this.elements = new Array<BlockItem>(...elements);\n    }\n\n    toHtml(st: Array<string>): void {\n        console.log('p: ', this.elements);\n        st.push('<p>');\n        for (const elem of this.elements) {\n            elem.toHtml(st);\n        }\n        st.push('</p>');\n    }\n\n    toMarkdown(st: Array<string>): void {\n        for (const elem of this.elements) {\n            elem.toMarkdown(st);\n        }\n    }\n\n\n}\n","import {Markable} from './Markable';\nimport {BlockItem} from './BlockItem';\n\nexport class Header implements Markable {\n\n    private elements: Array<BlockItem>;\n    private hLevel: number;\n\n    constructor(elements: Array<BlockItem>, hLevel: number) {\n        this.hLevel = hLevel;\n        this.elements = new Array<BlockItem>(...elements);\n    }\n\n    toHtml(st: Array<string>): void {\n        st.push(`<h${this.hLevel}>`);\n        for (const elem of this.elements) {\n            elem.toHtml(st);\n        }\n        st.push(`</h${this.hLevel}>`);\n    }\n\n    toMarkdown(st: Array<string>): void {\n        throw st;\n    }\n\n}\n","import {BlockItem} from './BlockItem';\n\nexport class Text implements BlockItem {\n    private text: string;\n\n    constructor(text: string) {\n        this.text = text;\n    }\n\n    toHtml(st: Array<string>): void {\n        st.push(this.text);\n    }\n\n    toMarkdown(st: Array<string>): void {\n        st.push(this.text);\n    }\n\n\n}\n","import {BlockItem} from './BlockItem';\n\nexport abstract class BlockMarkableItem implements BlockItem {\n    private elements: Array<BlockItem>;\n\n    protected constructor(elements: Array<BlockItem>) {\n        this.elements = new Array<BlockItem>(...elements);\n    }\n\n    protected toMarkdownSuper(start: string, end: string, st: Array<string>): void {\n        st.push(start);\n        for (const elem of this.elements) {\n            elem.toMarkdown(st);\n        }\n        st.push(end);\n    }\n\n    protected toHtmlSuper(start: string, end: string, st: Array<string>): void {\n        st.push(start);\n        for (const elem of this.elements) {\n            elem.toMarkdown(st);\n        }\n        st.push(end);\n    }\n\n    abstract toMarkdown(st: Array<string>): void;\n\n    abstract toHtml(st: Array<string>): void;\n}\n","import {BlockMarkableItem} from './BlockMarkableItem';\nimport {BlockItem} from './BlockItem';\n\nexport class Strikeout extends BlockMarkableItem {\n    constructor(elements: Array<BlockItem>) {\n        super(elements);\n    }\n\n    toHtml(st: Array<string>): void {\n        super.toHtmlSuper('<s>', '</s>', st);\n    }\n\n    toMarkdown(st: Array<string>): void {\n        super.toMarkdownSuper('~', '~', st);\n    }\n}\n","import {BlockMarkableItem} from './BlockMarkableItem';\nimport {BlockItem} from './BlockItem';\n\nexport class Strong extends BlockMarkableItem {\n    constructor(elements: Array<BlockItem>) {\n        super(elements);\n    }\n\n    toHtml(st: Array<string>): void {\n        super.toHtmlSuper('<strong>', '</strong>', st);\n    }\n\n    toMarkdown(st: Array<string>): void {\n        super.toMarkdownSuper('__', '__', st);\n    }\n}\n","import {BlockItem} from './BlockItem';\nimport {BlockMarkableItem} from './BlockMarkableItem';\n\nexport class Emphasis extends BlockMarkableItem {\n\n    constructor(elements: Array<BlockItem>) {\n        super(elements);\n    }\n\n    toHtml(st: Array<string>): void {\n        super.toHtmlSuper('<em>', '</em>', st);\n    }\n\n    toMarkdown(st: Array<string>): void {\n        super.toMarkdownSuper('*', '*', st);\n    }\n}\n","import {BlockMarkableItem} from './BlockMarkableItem';\nimport {BlockItem} from './BlockItem';\n\nexport class Code extends BlockMarkableItem {\n\n    constructor(elements: Array<BlockItem>) {\n        super(elements);\n    }\n\n    toHtml(st: Array<string>): void {\n        super.toHtmlSuper('`', '`', st);\n    }\n\n    toMarkdown(st: Array<string>): void {\n        super.toMarkdownSuper('<code>', '</code>', st);\n    }\n}\n","import {BaseParser} from './BaseParser';\nimport {Markable} from './markup/Markable';\nimport {TokenReader} from './TokenReader';\nimport {Paragraph} from './markup/Paragraph';\nimport {Header} from './markup/Header';\nimport {Token} from './Token';\nimport {BlockItem} from './markup/BlockItem';\nimport {Text} from './markup/Text';\nimport {Strikeout} from './markup/Strikeout';\nimport {Strong} from './markup/Strong';\nimport {Emphasis} from './markup/Emphasis';\nimport {Code} from './markup/Code';\n\n\nexport class MdParser extends BaseParser {\n    private readonly source: Array<string>;\n    private curElem: string = '';\n    private curLine: string | null = '';\n    private headerStarts = ['###### ', '##### ', '#### ', '### ', '## ', '# '];\n\n    private hLevel: number = 0;\n\n    constructor(data: string) {\n        super();\n        this.source = data.split('\\n');\n        console.log(this.source);\n    }\n\n\n    public parse(): Array<Markable> {\n        const ans = new Array<Markable>();\n        while (this.nextElement()) {\n            if (this.isParagraph()) {\n                this.tr = new TokenReader(this.curElem);\n                this.nextToken();\n                ans.push(new Paragraph(this.parseItems()));\n            } else {\n                this.tr = new TokenReader(this.curElem.substring(this.hLevel + 1));\n                this.nextToken();\n                ans.push(new Header(this.parseItems(), this.hLevel));\n            }\n        }\n        return ans;\n    }\n\n    private isText(token: Token) {\n        return token === Token.TEXT;\n    }\n\n    private parseItems(): Array<BlockItem> {\n        const ans = new Array<BlockItem>();\n        while (this.curToken !== Token.END) {\n            if (this.isText(this.curToken)) {\n                ans.push(new Text(this.curStringToken));\n                this.nextToken();\n            } else if (this.curToken === Token.IMG) {\n                ans.push(this.tr.getImg());\n                this.nextToken();\n            } else {\n                const start: Token = this.curToken;\n                this.nextToken();\n                ans.push(...this.parseItem(start));\n            }\n        }\n        return ans;\n    }\n\n    private parseItem(start: Token): Array<BlockItem> {\n        const ans = new Array<BlockItem>();\n        while (this.curToken !== Token.END && this.curToken !== start) {\n            if (this.isText(this.curToken)) {\n                ans.push(new Text(this.curStringToken));\n                this.nextToken();\n            } else if (this.curToken === Token.IMG) {\n                ans.push(this.tr.getImg());\n                this.nextToken();\n            } else {\n                const st: Token = this.curToken;\n                this.nextToken();\n                ans.push(...this.parseItem(st));\n            }\n        }\n        if (this.curToken === start) {\n            this.nextToken();\n            return this.create(ans, start);\n        } else if (start === Token.EMPHASIS || start === Token._EMPHASIS) {\n            const temp = new Array<BlockItem>();\n            temp.push(new Text(this.tokenToString(start)));\n            temp.push(...ans);\n            this.nextToken();\n            return temp;\n        } else {\n            throw 'Unclosed tag! expected ' + start + 'found ' + this.curToken;\n        }\n    }\n\n    private tokenToString(token: Token): string {\n        switch (token) {\n            case Token.STRIKEOUT: {\n                return '--';\n            }\n            case Token.STRONG: {\n                return '**';\n            }\n            case Token.__STRONG: {\n                return '__';\n            }\n            case Token.EMPHASIS: {\n                return '*';\n            }\n            case Token._EMPHASIS: {\n                return '_';\n            }\n            case Token.CODE: {\n                return '`';\n            }\n            default: {\n                throw 'atata';\n            }\n        }\n    }\n\n    private create(ans: Array<BlockItem>, token: Token): Array<BlockItem> {\n        switch (token) {\n            case Token.STRIKEOUT: {\n                return [new Strikeout(ans)];\n            }\n            case Token.STRONG: {\n                return [new Strong(ans)];\n            }\n            case Token.__STRONG: {\n                return [new Strong(ans)];\n            }\n            case Token.EMPHASIS: {\n                return [new Emphasis(ans)];\n            }\n            case Token._EMPHASIS: {\n                return [new Emphasis(ans)];\n            }\n            case Token.CODE: {\n                return [new Code(ans)];\n            }\n            default: {\n                throw 'atata';\n            }\n        }\n    }\n\n\n    private skipEmpties(): void {\n        this.curLine = this.next();\n        while (this.curLine !== null && this.curLine === '') {\n            this.curLine = this.next();\n        }\n    }\n\n    private nextElement(): boolean {\n        this.skipEmpties();\n        if (this.curLine === null) {\n            return false;\n        }\n        const elem = new Array<string>();\n        elem.push(this.curLine);\n        this.curLine = this.next();\n        while (this.curLine !== null && this.curLine !== '') {\n            elem.push('\\n');\n            elem.push(this.curLine);\n            this.curLine = this.next();\n        }\n        this.curElem = elem.join('');\n        return true;\n    }\n\n    next(): string | null {\n        const exp = this.source.length === 0 ? null : this.source.shift();\n        if (exp !== undefined) {\n            return exp\n        }\n        return null;\n    }\n\n    private isParagraph(): boolean {\n        for (const headerStart of this.headerStarts) {\n            if (this.curElem.startsWith(headerStart)) {\n                this.hLevel = headerStart.length - 1;\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n}\n"],"names":["Token","Image","name","src","toHtml","st","push","this","toMarkdown","TokenReader","source","CODE","Map","STRONG","EMPHASIS","STRIKEOUT","_EMPHASIS","__STRONG","IMG","pos","checkTag","tags","tag","startsWith","curTag","test","ch","length","parseImg","mid","end","start","imgName","substring","imgSrc","getImg","nextToken","END","curStringToken","temp","strToToken","get","curToken","undefined","sb","Array","charAt","TEXT","join","getStringToken","BaseParser","tr","Paragraph","elements","console","log","Header","hLevel","Text","text","BlockMarkableItem","toMarkdownSuper","toHtmlSuper","Strikeout","_BlockMarkableItem","Strong","Emphasis","Code","MdParser","data","split","_this","parse","ans","nextElement","isParagraph","curElem","parseItems","isText","token","parseItem","create","tokenToString","skipEmpties","curLine","next","elem","exp","shift","headerStarts","headerStart"],"mappings":"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"}